[
["index.html", "Методические указания по выполнению расчётно-графической работы в R Раздел 1 Задание на расчётно-графическую работу 1.1 Порядок выполнения работы", " Методические указания по выполнению расчётно-графической работы в R Михаил Лысенко 2020-04-12 Раздел 1 Задание на расчётно-графическую работу Федеральной службой государственной статистики РФ ежеквартально проводятся бюджетные обследования домашних хозяйств по всем регионам России об условиях проживания и уровне благосостояния населения. Необходимо проанализировать данные обследования о расходах и доходах домохозяйств. В рамках работы данные обследований описываются следующими показателями: - код территории по ОКАТО (переменная ТЕРРИТОРИЯ) - тип населенного пункта (переменная ТИПНАС, 1 - город, 2 - село) - расходы на продукты питания (переменная ПРОДПИТ, y(1)) - расходы на непродовольственные товары (переменная НЕПРОД, y(2)) - расходы на оплату услуг (переменная УСЛУГИ, y(3)) - расходы на покупку алкогольной продукции (переменная АЛКО, x0) - доходы домохозяйства (переменная ДОХОД, x1) - сбережения домохозяйства (переменная СБЕРЕЖ, x2) - число людей в домохозяйстве (ЧИСЛОЛЮД, x3) - число детей в домохозяйстве (ЧИСЛОДЕТ, x4) Федеральный округ и отклик y берутся в соответствии с выданным вариантом. Скачать исходные данные 1.1 Порядок выполнения работы 1. Прочитать исходные данные, Исследовать структуру данных: сколько наблюдений, какие поля, какого типа, есть ли пропуски. Исключить отклики y, не соответствующие выданному варианту. 2. Дополнить данные полями из файла codes.xls (скачать): - Код: код региона по ОКАТО, соответствующий переменной ТЕРРИТОРИЯ в данных по обследованиям - Название: название региона - ФО: федеральный округ, к которому относится регион - hc-a2: код региона, соответствующий переменной hc-a2 карты “Russia with disputed territories” библиотеки Highcharter Сколько наблюдений приходится на каждый из федеральных округов? Вывести топ-10 регионов по убыванию количества наблюдений. Вывести топ-10 регионов по убыванию среднего значения отклика y. 3. Рассчитать новую переменную: доход на одного взрослого (x1/(x3-x4)). По полученному показателю Для каждого региона рассчитать среднее арифметическое и медиану. Отобразить полученные значения на карте “Russia with disputed territories” библиотеки Highcharter (с учётом, что в данных по обследованиям ХМАО и ЯНАО относятся к Тюменской области, а Ненецкий АО к Архангельской области). Цветовая шкала в зависимости от среднего, во всплывающем окне выводить название региона, среднее и медиану. Проанализировать результаты, сделать выводы. Как различаются регионы между собой? Отличается ли средний доход от медианного дохода. В связи с чем возникают различия? 4. Отфильтровать данные, оставив наблюдения по федеральному округу в соответствии с вариантом. Отклик На одном рисунке построить корреляционные поля, рассчитать коэффициенты корреляции и распределения между переменными y, x0, x1, x2, x3, x4 (функция ggpairs() библиотеки GGally). Сделать выводы о наличии связи между показателями, её виде и форме. 5. Провести проверку данных на наличие выбросов с удалением всех наблюдений \\(\\overline{x}_{(i)}=(x_{1i},x_{2i})\\), для которых выполняется соотношение \\(h_{i}=\\overline{x}_{(i)}(X^{T}X)^{-1}\\overline{x}_{(i)}^{T}\\geqslant \\frac{3}{N}\\), где \\(X\\) - матрица, составленная из значений переменных x1 и x2. На основе оставшихся наблюдений перестроить корреляционные поля, сделать сравнения. Провести расчет основных выборочных характеристик, проинтерпретировать результаты, сделать выводы. 6. Рассчитать выборочные парные коэффициенты корреляции для всех возможных пар переменных, проверить их на значимость, сделать выводы о тесноте связи между признаками. 7. Построить корреляционное поле между откликом и доходом. Построить линейную модель парной регрессии между этими переменными. Добавить линию регрессии на координатную плоскость. Проанализировать результаты (форма корреляционного поля, что показывают оценки параметров, каково качество модели, выводы о значимости параметров и модели). Проделать то же самое по прологарифмированным переменным. Сделать выводы, что изменилось? Доп. баллы: для двух моделей построить и проанализировать корреляционное поле между доходом и модулем остатков модели. С помощию критерия Голдфельда-Квандта изучить обе модели на наличие гетероскедастичности. Сделать выводы. 8. В модель с логарифмированными переменными добавить факторную переменную ТИПНАС, учитывая взаимодействие этой переменной с величиной дохода. Построить корреляционное поле, новую переменную обозначив цветом. Добавить линии регрессии, проинтерпретировать результаты и сделать выводы. 9. Построить линейную модель множественной регресии по всем входным переменным x0, x1, x2, x3, x4, сделать выводы. Проранжировать входные факторы по степени влияния на отклик при помощи коэффициентов эластичности. Отобрать два наиболее сильно влияющих фактора, изобразить в трёх измерениях модель частной регрессии с этими факторами, заменив медианами значения остальных переменных: добавить исходные данные, плоскость регрессии и плоскости 95% доверительного интервала. Затем построить этот график, прологарифмировав значения отклика, прогнозов и доверительных интервалов. Сделать выводы. 10. Сделать общие выводы по проделанной работе в терминах исходных показателей. Предложить рекомендации по улучшению экономической ситуации в федеральном округе. "],
["intro.html", "Раздел 2 Начало работы 2.1 Установка R и Rstudio, знакомство с рабочей областью 2.2 Типы переменных 2.3 Основные операторы 2.4 Структуры данных", " Раздел 2 Начало работы 2.1 Установка R и Rstudio, знакомство с рабочей областью Скачиваем установочный файл R по ссылке. (кнопка “Download R 3.6.3 for Windows” или более поздняя версия). Запускаем, устанавливаем без изменений. Скачиваем и устанавливаем RStudio с официального сайта. RStudio - среда разработки для языка R, позволяющая работать более комфортно. Запускаем RStudio, создаём новый скрипт: File -&gt; New File -&gt; R Script Рабочая область будет разделена на четыре части. Слева вверху - скрипт, то есть код, написанный и сохранённый в отдельном файле с расширением .R Слева внизу - консоль, в которой отображаются команды и ход их исполнения. Команды можно прописывать и выполнять сразу в консоли Это удобнее делать в случае, если это разовая команда, которую не имеет смысла сохранять в скрипте. Для того, чтобы исполнить команды из скрипта, нужно поставить курсор в нужную строку, либо выдалить нужную часть скрипта и нажать Ctrl+Enter. Справа вверху - рабочая среда (Environment) - список всех объектов, с которыми можно работать. Изначально он будет пуст. Справа внизу обычно выводятся графики (вкладка Plots), справка о функциях (вкладка Help), список установленных библиотек (Packages). Пример: В консоль было введено 2*5 и там же получен результат исполнения - 10. Затем был выделен и запущен скрипт из верхней области: переменной a присвоен (команда &lt;-) результат выражения 9/3, переменная появилась в рабочем пространстве справа. Повторный вызов переменной a выводит в консоль сохранённое значение - 3. Затем был построен график, результат исполнения команды отобразился в нижнем правом углу во вкладке Plots. При работе полезно использовать кнопку Tab, чтобы вызывать окно с подсказками Комментарии в скрипте можно записывать после символа #. Комментарии не исполняются и нужны для создания пометок внутри кода Видео Б.Демешева “Запуск R в первый раз. Консольный режим в R” 2.2 Типы переменных Чтобы узнать тип переменной, используется функция class() NA - переменная для пропущенного значения (Not Available) Основные типы переменных: Логические (TRUE, T, FALSE, F) class(TRUE) # TRUE, T - истина; FALSE, F - ложь # [1] &quot;logical&quot; Числовые (4, -5.5, 100, 1.2e+10, Inf, -Inf, NaN) NaN - “Not a Number” - получается в результате некоторых операций, напр. квадратного корня из (-1). Подробнее class(5.22e+3) # экспоненциальная запись, = 5.22*10^3 = 5220 # [1] &quot;numeric&quot; class(-Inf) # минус бесконечность # [1] &quot;numeric&quot; Текстовые (\"ch\", \"10\", ' - ', '') class(&#39;&#39;) # записываются в одинарных либо двойных кавычках # [1] &quot;character&quot; Менять тип переменных можно с помощью функций: as.logical() as.logical(-595) # число 0 меняется на FALSE, остальные числа - на TRUE # [1] TRUE as.logical(&quot;F&quot;) # [1] FALSE as.numeric() as.numeric(&#39;950&#39;) # [1] 950 as.numeric(T) # TRUE меняется на число 1, FALSE на 0 # [1] 1 as.character() as.character(10) # [1] &quot;10&quot; as.character(FALSE) # [1] &quot;FALSE&quot; 2.3 Основные операторы Математические: +, -, *, /, ^ - сложение, вычитание, умножение, деление, возведение в степень (2*3+8/2)^(5-3) # [1] 100 Сравнения: &lt;, &gt;, &lt;=, &gt;=, ==, != - меньше, больше, меньше либо равно, больше либо равно, равно, не равно Результат - логическая переменная TRUE или FALSE 10&lt;=5 # сравнение чисел # [1] FALSE 0==FALSE # FALSE заменяется на 0, TRUE на 1 # [1] TRUE &#39;faf&#39;&lt;&#39;fb&#39; # текстовые переменые сравниваются по алфавиту, цифры считаются меньше букв # [1] TRUE Логические: &amp;, |, ! - И, ИЛИ, НЕ TRUE &amp; (1&gt;0) &amp; (&#39;faf&#39;!=&#39;ga&#39;) # TRUE, если все составляющие тоже TRUE. При одном FALSE всё выражение FALSE # [1] TRUE (2==22) | (5&gt;2) | (F) # TRUE, если хотя бы одно из составляющих TRUE. Иначе FALSE # [1] TRUE !(1&gt;0) # отрицание, F меняется на T и наоборот # [1] FALSE Преобразование матриц %*% - умножение матриц matrix(2,4,6)%*%matrix(3,6,2) # [,1] [,2] # [1,] 36 36 # [2,] 36 36 # [3,] 36 36 # [4,] 36 36 t() - транспонирование матрицы t(matrix(2,4,6)%*%matrix(3,6,2)) # транспонируем из примера выше # [,1] [,2] [,3] [,4] # [1,] 36 36 36 36 # [2,] 36 36 36 36 solve() - нахождение обратной матрицы solve(matrix(c(3,6,5,8,4,3,2,4,5), 3, 3)) # [,1] [,2] [,3] # [1,] -0.13333333 0.56666667 -0.4 # [2,] 0.16666667 -0.08333333 0.0 # [3,] 0.03333333 -0.51666667 0.6 %in% - есть ли значение слева от оператора в наборе значений справа 5 %in% c(2,5,3,NA) # 5 есть в векторе справа # [1] TRUE c(1,2, NA) %in% c(2,3,4,NA) # 1 нет, 2 есть, NA есть # [1] FALSE TRUE TRUE Видео Б.Демешева “Написание первого скрипта в R” 2.4 Структуры данных Вектор - последовательность значений, все элементы вектора должны быть одного типа (числовые, текстовые и т д). Создаётся с помощью оператора c(), внутри которого, через запятую, перечисляются элементы вектора c(-2, Inf, NA, 1000) # [1] -2 Inf NA 1000 c(&#39;aa&#39;, &#39;B&#39;, NA) # [1] &quot;aa&quot; &quot;B&quot; NA c(F,F,T) # [1] FALSE FALSE TRUE Некоторые способы создания: С помощью оператора : , который создаёт последовательность чисел от числа слева до числа справа с шагом в единицу -5:5 # [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 2.7:8.5 # [1] 2.7 3.7 4.7 5.7 6.7 7.7 Функция rep() - реплицирует (копирует) первый аргумент столько раз, сколько указано во втором аргументе rep(NA, 5) # [1] NA NA NA NA NA rep(&quot; - &quot;, 10) # [1] &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; Функция seq() - создаёт последовательность чисел от минимального (аргумент 1) до максимального (аргумент 2) с шагом, равным аргументу 3 seq(1,100,22) # [1] 1 23 45 67 89 seq(15,-20,-4) # [1] 15 11 7 3 -1 -5 -9 -13 -17 Способы можно комбинировать rep(c(-Inf,5:8,NaN), 3) # [1] -Inf 5 6 7 8 NaN -Inf 5 6 7 8 NaN -Inf 5 6 # [16] 7 8 NaN Матрица (двумерная) - набор данных, имеющий два измерения. Все элементы матрицы должны быть одного типа. Создаётся путём указания вектора значений, которые последовательно распределяются по заданным размерностям матрицы (по умолчанию заполняется по колонкам) matrix(1:6, 2, 3) # вектор от 1 до 6 распределяем на матрицу 2х3 по колонкам # [,1] [,2] [,3] # [1,] 1 3 5 # [2,] 2 4 6 matrix(1:12, 4, 3, byrow = T) # вектор от 1 до 12 распределяем на матрицу 4х3 по строкам # [,1] [,2] [,3] # [1,] 1 2 3 # [2,] 4 5 6 # [3,] 7 8 9 # [4,] 10 11 12 Список - объект типа list, элементы которого могут быть объектами любого типа Создаётся командой list() list1 &lt;- list(&#39;obj1&#39; = 5:10, &#39;элемент 2&#39; = &#39;текст&#39;, &#39;таблица&#39;=data.frame(a=1:3, b=2:4)) # созданный список записали в переменную list1 list1 # вывели весь список # $obj1 # [1] 5 6 7 8 9 10 # # $`элемент 2` # [1] &quot;текст&quot; # # $таблица # a b # 1 1 2 # 2 2 3 # 3 3 4 list1$`элемент 2` # индексация по названию объекта в списке # [1] &quot;текст&quot; list1[[3]] # индексация по порядковому номеру объекта в списке # a b # 1 1 2 # 2 2 3 # 3 3 4 Таблицы data.frame - класс таблиц. столбцы в data.frame могут быть разного типа, но элементы внутри столбца - одного типа. Можно представлять объекты этого класса как список векторов одинаковой длины. Создаётся командой data.frame(). df1 &lt;- data.frame(col1=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;d&#39;,&#39;d&#39;,&#39;e&#39;,&#39;e&#39;), col2=2, col3=c(4,7,5.5,3,9,0,9,5)) df1$col1 # знак $ для индексации по колонкам # [1] a b c d d d e e # Levels: a b c d e df1[c(2,1), c(&#39;col1&#39;, &#39;col2&#39;)] # индексация в квадратных скобках: [ вектор номеров строк , вектор названий колонок ] # col1 col2 # 2 b 2 # 1 a 2 df1[c(F,T,T,F,T,F,F,F),] # индексация с помощью логического вектора, выводятся строки с TRUE. Обязательно указываем запятую после индексации по строкам # col1 col2 col3 # 2 b 2 7.0 # 3 c 2 5.5 # 5 d 2 9.0 df1[df1$col1 %in% c(&#39;b&#39;, &#39;d&#39;),] # df1$col1 %in% c(&#39;b&#39;, &#39;d&#39;) возвращает логический вектор, указывая, где в col1 находятся &#39;b&#39; или &#39;d&#39; # col1 col2 col3 # 2 b 2 7 # 4 d 2 3 # 5 d 2 9 # 6 d 2 0 # логический вектор используется для индексации как в примере с data.frame class(df1[,1]) # столбец 1 таблицы имеет класс factor - класс для категориальных переменных, с уровнями (возможными значениями) a, b, c # [1] &quot;factor&quot; data.table - класс таблиц одноимённого пакета. По сути, это улучшенная версия data.frame. Об установке и использовании библиотек говорится в разделе 3. library(data.table) dt1 &lt;- as.data.table(df1) class(dt1) # это также и data.frame # [1] &quot;data.table&quot; &quot;data.frame&quot; В квадратных скобках после data.table можно выполнять гораздо больше задач, чем в data.frame Область внутри квадратных скобок делится на 3 части запятыми: [выбор строк , выбор и преобразование столбцов , группировка по признаку] Строки можно выбирать с помощью номеров строк, логическими векторами, аналогично data.frame В data.table переменная .N содержит в себе количество строк в таблице (либо в группе, если применяется группировка) dt1[(.N-2):.N] # выбраны последние 3 строки # col1 col2 col3 # 1: d 2 0 # 2: e 2 9 # 3: e 2 5 Выбирать строки по условиям (напр, где в col1 содержится ‘b’ или ‘d’), немного удобнее, чем в data.frame: dt1[col1 %in% c(&#39;b&#39;, &#39;d&#39;)] # после выбора строк не обязательно прописывать запятую, как требуется в data.frame # col1 col2 col3 # 1: b 2 7 # 2: d 2 3 # 3: d 2 9 # 4: d 2 0 dt1[col1==&#39;d&#39; &amp; col3&gt;=3] # можно комбинировать несколько условий # col1 col2 col3 # 1: d 2 3 # 2: d 2 9 Во второй части квадратных скобок производятся операции над столбцами. Простое указание названия столбца возвращает столбец в виде вектора: dt1[ , col2] # поскольку выбор строк не осуществлялся, первая область перед запятой осталась пустой # [1] 2 2 2 2 2 2 2 2 Чтобы вернуть столбец или несколько столбцов как data.table, названия нужно перечислять списком, внутри list() или .() (в data.table .() эквивалентен списку, более удобен в использовании) dt1[col3&gt;=6 , list(col1)] # col1 # 1: b # 2: d # 3: e dt1[col1==&#39;e&#39; , .(col2, col3)] # col2 col3 # 1: 2 9 # 2: 2 5 Для преобразования столбцов используется оператор :=. С его помощью можно изменять текущие, создавать новые, удалять столбцы. dt1[,col1:=as.character(col1)] # изменим тип столбца с factor на character dt1[,class(col1)] # [1] &quot;character&quot; dt1[,col4:=col3^col2] # создаём новый столбец, в котором будет результат возведения значения в col3 в степень из col2 dt1[,col2:=NULL] # NULL - нулевой, несуществующий объект. col2 будет удалён dt1 # col1 col3 col4 # 1: a 4.0 16.00 # 2: b 7.0 49.00 # 3: c 5.5 30.25 # 4: d 3.0 9.00 # 5: d 9.0 81.00 # 6: d 0.0 0.00 # 7: e 9.0 81.00 # 8: e 5.0 25.00 В третьей части квадратных скобок указывается, по какому столбцу (столбцам) производить группировку dt1[,.N,col1] # сколько в таблице строк для каждого уникального значения из col1 # col1 N # 1: a 1 # 2: b 1 # 3: c 1 # 4: d 3 # 5: e 2 dt1[col3&gt;3, .(mean_col4=mean(col4)),col1] # выбираем только строки с col3&gt;3, по ним рассчитываем средний col4 для каждого значения из col1 # col1 mean_col4 # 1: a 16.00 # 2: b 49.00 # 3: c 30.25 # 4: d 81.00 # 5: e 53.00 # новый столбец назовём mean_col4, выражение mean_col4=mean(col4) обернём в список .() Можно группировать по нескольким столбцам, перечисляя их в списке .(). Тогда будет возвращён результат для каждой уникальной связки значений этих переменных dt1[, .(quantity=.N),.(col1,col3)] # для каждой уникальной пары значений col1 и col3 подсчитаем, сколько присутствует наблюдений # col1 col3 quantity # 1: a 4.0 1 # 2: b 7.0 1 # 3: c 5.5 1 # 4: d 3.0 1 # 5: d 9.0 1 # 6: d 0.0 1 # 7: e 9.0 1 # 8: e 5.0 1 # результат - везде 1, так как в исходной таблице нет повторяющихся комбинации значений col1 и col3 Далее в методичке для всех таблиц будет использоваться класс data.table Руководство по data.table (на русском языке) "],
["functions.html", "Раздел 3 Библиотеки и функции 3.1 Некоторые полезные функции 3.2 Пакеты", " Раздел 3 Библиотеки и функции 3.1 Некоторые полезные функции Шпаргалка с основными операторами, функциями, командами (на английском языке) Расчётные функции sum(x) - сумма sum(-10:12) # [1] 23 sum(c(1,2,3,4,NA,5), na.rm=T) # na.rm=T - не обращать внимание на пропуски при вычислении. Применяется во многих подобных функциях # [1] 15 mean(x) - среднее mean(-10:12) # [1] 1 mean(c(1,2,3,4,NA,5), na.rm=T) # [1] 3 min(x), max(x) - минимум, максимум min(-10:12) # [1] -10 max(c(1,2,3,4,NA,5), na.rm=T) # [1] 5 log(x, base) - логарифм x по основанию base log(1:5) # без указания основания берётся натуральный логарифм # [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 log(1:5, base = 5) # [1] 0.0000000 0.4306766 0.6826062 0.8613531 1.0000000 cor(x, y) - парный коэффициент корреляции между двумя векторами cor(1:5, c(1,1,3,5,5)) # [1] 0.9486833 var(x) - дисперсия sd(x) - стандартное отклонение median(x) - медиана Работа с данными dt2 &lt;- data.table(col1=c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;, &#39;f&#39;), col2=c(1, 2, 3, 6, 5, 4, 3)) head(x, n), tail(x, n) - первые или последние n элементов объекта x (по умолчанию n = 6) head(dt2, 3) # col1 col2 # 1: a 1 # 2: b 2 # 3: c 3 tail(dt2,2) # col1 col2 # 1: d 4 # 2: f 3 summary(x) - вывод основных параметров объекта summary(dt2) # col1 col2 # Length:7 Min. :1.000 # Class :character 1st Qu.:2.500 # Mode :character Median :3.000 # Mean :3.429 # 3rd Qu.:4.500 # Max. :6.000 length() - длина объекта length(dt2[,col2]) # [1] 7 nrow(), ncol() - число строк и число стобцов c(nrow(dt2), ncol(dt2)) # [1] 7 2 sort() - отсортировать вектор (по умолчанию - по возрастанию) sort(dt2[,col2]) # [1] 1 2 3 3 4 5 6 sort(dt2[,col2], decreasing = T) # по убыванию # [1] 6 5 4 3 3 2 1 order() - возвращает индексы элементов в порядке возрастания order(dt2[,col2]) # [1] 1 2 3 7 6 5 4 order(dt2[,col2], decreasing = T) # в порядке убывания # [1] 4 5 6 3 7 2 1 dt2[order(col2, decreasing = T)] # передаём индексы таблице - получаем отсортированную по убыванию col2 # col1 col2 # 1: d 6 # 2: d 5 # 3: d 4 # 4: c 3 # 5: f 3 # 6: b 2 # 7: a 1 table(x) - возвращает таблицу с уникальными значениями вектора x и числом их вхождений table(dt2[,col1]) # # a b c d f # 1 1 1 3 1 sort(table(dt2[,col1]), decreasing = T)[1:3] # сортируем по убыванию и берём топ 3 значений # # d a b # 3 1 1 unique() - возвращает объект с уникальными значениями (без повторений) unique(dt2[,col2]) # [1] 1 2 3 6 5 4 apply(),lapply(), sapply() - применение функции к каждому элементу объекта. apply применяется к матрицам, таблицам; lapply возвращает список; sapply возвращает вектор lapply(1:5, function(x)x^2) # [[1]] # [1] 1 # # [[2]] # [1] 4 # # [[3]] # [1] 9 # # [[4]] # [1] 16 # # [[5]] # [1] 25 sapply(1:5, function(x)x^2) # [1] 1 4 9 16 25 apply(dt2, MARGIN = 2, function(x)length(unique(x))) # количество уникальных значений по столбцам. Чтобы применить функцию к строкам, MARGIN = 1 # col1 col2 # 5 6 rbind(), cbind() - соединить несколько таблиц по строкам, столбцам (r- для row, c- для column) rbind(dt2, data.table(col1=&#39;A&#39;, col2=10)) # названия столбцов в таблицах должны соответствовать друг другу # col1 col2 # 1: a 1 # 2: b 2 # 3: c 3 # 4: d 6 # 5: d 5 # 6: d 4 # 7: f 3 # 8: A 10 cbind(dt2, data.table(col3=11:17)) # col1 col2 col3 # 1: a 1 11 # 2: b 2 12 # 3: c 3 13 # 4: d 6 14 # 5: d 5 15 # 6: d 4 16 # 7: f 3 17 merge() - объединение двух таблиц по общему ключу Параметр by указывает на наименование столбца с ключами. Если столбцы с ключами для первой и второй таблицы имеют разные названия, они перечисляются отдельно параметрами by.x и by.y для первой и второй таблицы соответственно. По умолчанию в результате остаются только строки, имеющие общие ключи в обеих таблицах: merge(dt2, data.table(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), # создали новую таблицу by=&#39;col1&#39;) # по колонке col1 # col1 col2 col3 # 1: a 1 11 # 2: d 6 15 # 3: d 5 15 # 4: d 4 15 # 5: f 3 13 Если нужно сохранить строки первой или второй таблицы, добавляются параметры all.x=T или all.y=T. На месте, где нет совпадений, появятся пропуски NA merge(dt2, data.table(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), by=&#39;col1&#39;, all.y=T ) # col1 col2 col3 # 1: A NA 20 # 2: a 1 11 # 3: d 6 15 # 4: d 5 15 # 5: d 4 15 # 6: f 3 13 merge(dt2, data.table(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), by=&#39;col1&#39;, all.x=T, all.y=T ) # col1 col2 col3 # 1: A NA 20 # 2: a 1 11 # 3: b 2 NA # 4: c 3 NA # 5: d 6 15 # 6: d 5 15 # 7: d 4 15 # 8: f 3 13 3.2 Пакеты Пакет - набор функций и наборов данных. Существуют стандартные пакеты, которые доступны сразу после установки R и позволяют R работать (например, base, stats, methods, utils). Также существуют сторонние пакеты, написанные различными авторами (например, data.table, который уже использовался нами ранее). Установить пакет можно с помощью команды install.packages(), внутри которой указывается название пакета в кавычках. Можно устанавливать пакеты с помощью интерфейса RStudio: Tools -&gt; Install Packages… или Install вкладки с пакетами Для использования пакета нужно его загрузить в текущую рабочую сессию с помощью функции library() library(data.table) Если пакетом нужно воспользоваться единожды, можно воспользоваться оператором ::, не загружая пакет (но быть установлен он должен). Перед :: указывается название пакета, после - вызываемая команда. Например: data.table::shift(1:10, 2) # функция сдвигает вектор, в данном случае на 2 шага вправо # [1] NA NA 1 2 3 4 5 6 7 8 Список сторонних пакетов, которые могут помочь в выполнении РГР: data.table - для работы с таблицами readxl - для чтения файлов с исходными данными в формате .xls, .xlsx Hmisc - имеется функция rcorr() для расчёта коэффициентов корреляции с проверкой значимости GGally - имеется функция ggpairs() для построения корреляционных полей между набором показателей e1071 - функции skewness() и kurtosis() для расчёта коэффициентов асимметрии и эксцесса broom - функция augment для построения таблицы с исходными данными, прогнозами, остатками и другими показателями на основе модели регрессии ggplot2 - один из самых популярных пакетов для визуализации данных highcharter - пакет для создания интерактивных графиков plotly - позволяет строить трехмерные интерактивные графики Чтобы прочитать данные из документов в формате .xls, .xlsx, используем функции read_xls(), read_xlsx() пакета readxl. В аргумент path нужно передать в кавычках путь к файлу, включая название самого файла с его расширением. Можно указывать полный путь к документу, например, 'C:/Users/Mihail/Documents/rgr_econometrics/_book/rgr_econometrics_files/codes.xls' (нужно использовать прямые слеши /) Можно указывать неполный путь, начиная от текущей рабочей директории. Функция getwd() позволяет узнать, какая директория является текущей. setwd() позволяет установыить другую директорию в качестве текущей. getwd() # [1] &quot;C:/Users/Mihail/Documents/rgr_econometrics&quot; В аргумент sheet можно передать номер листа, с которого нужно считать данные в документе. По умолчанию читается первый лист Посмотрим, объектом какого класса является результат выполнения функции: xlsx1 &lt;- readxl::read_xlsx(&#39;_book/rgr_econometrics_files/01 ДАННЫЕ для РГР-ФБЭ.xlsx&#39;) class(xlsx1) # [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; В результате чтения была получена таблица другого класса - tibble. Используем функцию as.data.table(), чтобы конвертировать таблицу в data.table: xlsx1 &lt;- as.data.table(xlsx1) class(xlsx1) # [1] &quot;data.table&quot; &quot;data.frame&quot; "]
]
