[
["index.html", "Методические указания по выполнению расчётно-графической работы в R Раздел 1 Задание на расчётно-графическую работу 1.1 Порядок выполнения работы", " Методические указания по выполнению расчётно-графической работы в R Михаил Лысенко 2020-04-11 Раздел 1 Задание на расчётно-графическую работу Федеральной службой государственной статистики РФ ежеквартально проводятся бюджетные обследования домашних хозяйств по всем регионам России об условиях проживания и уровне благосостояния населения. Необходимо проанализировать данные обследования о расходах и доходах домохозяйств. В рамках работы данные обследований описываются следующими показателями: - код территории по ОКАТО (переменная ТЕРРИТОРИЯ) - тип населенного пункта (переменная ТИПНАС, 1 - город, 2 - село) - расходы на продукты питания (переменная ПРОДПИТ, y(1)) - расходы на непродовольственные товары (переменная НЕПРОД, y(2)) - расходы на оплату услуг (переменная УСЛУГИ, y(3)) - расходы на покупку алкогольной продукции (переменная АЛКО, x0) - доходы домохозяйства (переменная ДОХОД, x1) - сбережения домохозяйства (переменная СБЕРЕЖ, x2) - число людей в домохозяйстве (ЧИСЛОЛЮД, x3) - число детей в домохозяйстве (ЧИСЛОДЕТ, x4) Федеральный округ и отклик y берутся в соответствии с выданным вариантом. 1.1 Порядок выполнения работы 1. Прочитать исходные данные, Исследовать структуру данных: сколько наблюдений, какие поля, какого типа, есть ли пропуски. Исключить отклики y, не соответствующие выданному варианту. 2. Дополнить данные полями из файла codes.csv: - Код: код региона по ОКАТО, соответствующий переменной ТЕРРИТОРИЯ в данных по обследованиям - Название: название региона - ФО: федеральный округ, к которому относится регион - hc-a2: код региона, соответствующий переменной hc-a2 карты “Russia with disputed territories” библиотеки Highcharter Сколько наблюдений приходится на каждый из федеральных округов? Вывести топ-10 регионов по убыванию количества наблюдений. Вывести топ-10 регионов по убыванию среднего значения отклика y. 3. Рассчитать новую переменную: доход на одного взрослого (x1/(x3-x4)). По полученному показателю Для каждого региона рассчитать среднее арифметическое и медиану. Отобразить полученные значения на карте “Russia with disputed territories” библиотеки Highcharter (с учётом, что в данных по обследованиям ХМАО и ЯНАО относятся к Тюменской области, а Ненецкий АО к Архангельской области). Цветовая шкала в зависимости от среднего, во всплывающем окне выводить название рениона, среднее и медиану. Проанализировать результаты, сделать выводы. Как различаются регионы между собой? Отличается ли средний доход от медианного дохода. В связи с чем возникают различия? 4. Отфильтровать данные, оставив наблюдения по федеральному округу в соответствии с вариантом. Отклик На одном рисунке построить корреляционные поля, рассчитать коэффициенты корреляции и распределения между переменными y, x0, x1, x2, x3, x4 (функция ggpairs() библиотеки GGally). Сделать выводы о наличии связи между показателями, её виде и форме. 5. Провести проверку данных на наличие выбросов с удалением всех наблюдений \\(\\overline{x}_{(i)}=(x_{1i},x_{2i})\\), для которых выполняется соотношение \\(h_{i}=\\overline{x}_{(i)}(X^{T}X)^{-1}\\overline{x}_{(i)}^{T}\\geqslant \\frac{3}{N}\\), где \\(X\\) - матрица, составленная из значений переменных x1 и x2. На основе оставшихся наблюдений провести расчет основных выборочных характеристик, проинтерпретировать результаты, сделать выводы. 6. Рассчитать выборочные парные коэффициенты корреляции для всех возможных пар переменных, проверить их на значимость, сделать выводы о тесноте связи между признаками. 7. Построить корреляционное поле между откликом и доходом. Построить линейную модель парной регрессии между этими переменными. Добавить линию регрессии на координатную плоскость. Проанализировать результаты (форма корреляционного поля, что показывают оценки параметров, каково качество модели, выводы о значимости параметров и модели). Проделать то же самое по прологарифмированным переменным. Сделать выводы, что изменилось? Доп. баллы: для двух моделей построить и проанализировать корреляционное поле между доходом и модулем остатков модели. С помощию критерия Голдфельда-Квандта изучить обе модели на наличие гетероскедастичности. Сделать выводы. 8. В модель с логарифмированными переменными добавить факторную переменную ТИПНАС, учитывая взаимодействие этой переменной с величиной дохода. Построить корреляционное поле, новую переменную обозначив цветом. Добавить линии регрессии, проинтерпретировать результаты и сделать выводы. 9. Построить линейную модель множественной регресии по всем входным переменным x0, x1, x2, x3, x4, сделать выводы. Проранжировать входные факторы по степени влияния на отклик при помощи коэффициентов эластичности. Отобрать два наиболее сильно влияющих фактора, изобразить в трёх измерениях модель частной регрессии с этими факторами, заменив медианами значения остальных переменных: добавить исходные данные, плоскость регрессии и плоскости 95% доверительного интервала. Затем построить этот график, прологарифмировав значения отклика, прогнозов и доверительных интервалов. Сделать выводы. 10. Сделать общие выводы по проделанной работе в терминах исходных показателей. "],
["intro.html", "Раздел 2 Начало работы 2.1 Установка R и Rstudio, знакомство с рабочей областью 2.2 Типы переменных 2.3 Основные операторы 2.4 Структуры данных 2.5 Некоторые полезные функции", " Раздел 2 Начало работы 2.1 Установка R и Rstudio, знакомство с рабочей областью Скачиваем установочный файл R по ссылке. (кнопка “Download R 3.6.3 for Windows” или более поздняя версия). Запускаем, устанавливаем без изменений. Скачиваем и устанавливаем RStudio с официального сайта. RStudio - среда разработки для языка R, позволяющая работать более комфортно. Запускаем RStudio, создаём новый скрипт: File -&gt; New File -&gt; R Script Рабочая область будет разделена на четыре части. Слева вверху - скрипт, то есть код, написанный и сохранённый в отдельном файле с расширением .R Слева внизу - консоль, в которой отображаются команды и ход их исполнения. Команды можно прописывать и выполнять сразу в консоли Это удобнее делать в случае, если это разовая команда, которую не имеет смысла сохранять в скрипте. Для того, чтобы исполнить команды из скрипта, нужно поставить курсор в нужную строку, либо выдалить нужную часть скрипта и нажать Ctrl+Enter. Справа вверху - рабочая среда (Environment) - список всех объектов, с которыми можно работать. Изначально он будет пуст. Справа внизу обычно выводятся графики (вкладка Plots), справка о функциях (вкладка Help), список установленных библиотек (Packages). Пример: В консоль было введено 2*5 и там же получен результат исполнения - 10. Затем был выделен и запущен скрипт из верхней области: переменной a присвоен (команда &lt;-) результат выражения 9/3, переменная появилась в рабочем пространстве справа. Повторный вызов переменной a выводит в консоль сохранённое значение - 3. Затем был построен график, результат исполнения команды отобразился в нижнем правом углу во вкладке Plots. При работе полезно использовать кнопку Tab, чтобы вызывать окно с подсказками Комментарии в скрипте можно записывать после символа #. Комментарии не исполняются и нужны для создания пометок внутри кода Шпаргалка с основными операторами, функциями, командами (на английском языке) Видео Б.Демешева “Запуск R в первый раз. Консольный режим в R” Видео Б.Демешева “Написание первого скрипта в R” 2.2 Типы переменных Чтобы узнать тип переменной, используется функция class() NA - переменная для пропущенного значения (Not Available) Основные типы переменных: Логические (TRUE, T, FALSE, F) class(TRUE) # TRUE, T - истина; FALSE, F - ложь ## [1] &quot;logical&quot; Числовые (4, -5.5, 100, 1.2e+10, Inf, -Inf, NaN) NaN - “Not a Number” - получается в результате некоторых операций, напр. квадратного корня из (-1). Подробнее class(5.22e+3) # экспоненциальная запись, = 5.22*10^3 = 5220 ## [1] &quot;numeric&quot; class(-Inf) # минус бесконечность ## [1] &quot;numeric&quot; Текстовые (“ch”, “10”, ’ - ‘,’’) class(&#39;&#39;) # записываются в одинарных либо двойных кавычках ## [1] &quot;character&quot; Менять тип переменных можно с помощью функций: as.logical() as.logical(-595) # число 0 меняется на FALSE, остальные числа - на TRUE ## [1] TRUE as.logical(&quot;F&quot;) ## [1] FALSE as.numeric() as.numeric(&#39;950&#39;) ## [1] 950 as.numeric(T) # TRUE меняется на число 1, FALSE на 0 ## [1] 1 as.character() as.character(10) ## [1] &quot;10&quot; as.character(FALSE) ## [1] &quot;FALSE&quot; 2.3 Основные операторы Математические: +, -, *, /, ^ - сложение, вычитание, умножение, деление, возведение в степень (2*3+8/2)^(5-3) ## [1] 100 Сравнения: &lt;, &gt;, &lt;=, &gt;=, ==, != - меньше, больше, меньше либо равно, больше либо равно, равно, не равно Результат - логическая переменная TRUE или FALSE 10&lt;=5 # сравнение чисел ## [1] FALSE 0==FALSE # FALSE заменяется на 0, TRUE на 1 ## [1] TRUE &#39;faf&#39;&lt;&#39;fb&#39; # текстовые переменые сравниваются по алфавиту, цифры считаются меньше букв ## [1] TRUE Логические: &amp;, |, ! - И, ИЛИ, НЕ TRUE &amp; (1&gt;0) &amp; (&#39;faf&#39;!=&#39;ga&#39;) # TRUE, если все составляющие тоже TRUE. При одном FALSE всё выражение FALSE ## [1] TRUE (2==22) | (5&gt;2) | (F) # TRUE, если хотя бы одно из составляющих TRUE. Иначе FALSE ## [1] TRUE !(1&gt;0) # отрицание, F меняется на T и наоборот ## [1] FALSE Преобразование матриц %*% - умножение матриц matrix(2,4,6)%*%matrix(3,6,2) ## [,1] [,2] ## [1,] 36 36 ## [2,] 36 36 ## [3,] 36 36 ## [4,] 36 36 t() - транспонирование матрицы t(matrix(2,4,6)%*%matrix(3,6,2)) # транспонируем из примера выше ## [,1] [,2] [,3] [,4] ## [1,] 36 36 36 36 ## [2,] 36 36 36 36 solve() - нахождение обратной матрицы solve(matrix(c(3,6,5,8,4,3,2,4,5), 3, 3)) ## [,1] [,2] [,3] ## [1,] -0.13333333 0.56666667 -0.4 ## [2,] 0.16666667 -0.08333333 0.0 ## [3,] 0.03333333 -0.51666667 0.6 %in% - есть ли значение слева от оператора в наборе значений справа 5 %in% c(2,5,3,NA) # 5 есть в векторе справа ## [1] TRUE c(1,2, NA) %in% c(2,3,4,NA) # 1 нет, 2 есть, NA есть ## [1] FALSE TRUE TRUE 2.4 Структуры данных Вектор - последовательность значений, все элементы вектора должны быть одного типа (числовые, текстовые и т д). Создаётся с помощью оператора c(), внутри которого, через запятую, перечисляются элементы вектора c(-2, Inf, NA, 1000) ## [1] -2 Inf NA 1000 c(&#39;aa&#39;, &#39;B&#39;, NA) ## [1] &quot;aa&quot; &quot;B&quot; NA c(F,F,T) ## [1] FALSE FALSE TRUE Некоторые способы создания: С помощью оператора : , который создаёт последовательность чисел от числа слева до числа справа с шагом в единицу -5:5 ## [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 2.7:8.5 ## [1] 2.7 3.7 4.7 5.7 6.7 7.7 Функция rep() - реплицирует (копирует) первый аргумент то количество раз, чему равен второй аргумент rep(NA, 5) ## [1] NA NA NA NA NA rep(&quot; - &quot;, 10) ## [1] &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; Функция seq() - создаёт последовательность чисел от минимального (аргумент 1) до максимального (аргумент 2) с шагом, равным аргументу 3 seq(1,100,22) ## [1] 1 23 45 67 89 seq(15,-20,-4) ## [1] 15 11 7 3 -1 -5 -9 -13 -17 Способы можно комбинировать rep(c(-Inf,5:8,NaN), 3) ## [1] -Inf 5 6 7 8 NaN -Inf 5 6 7 8 NaN -Inf 5 6 ## [16] 7 8 NaN Матрица (двумерная) - набор данных, имеющий два измерения. Все элементы матрицы должны быть одного типа. Создаётся путём указания вектора значений, которые последовательно распределяются по заданным размерностям матрицы (по умолчанию заполняется по колонкам) matrix(1:6, 2, 3) # вектор от 1 до 6 распределяем на матрицу 2х3 по колонкам ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 matrix(1:12, 4, 3, byrow = T) # вектор от 1 до 12 распределяем на матрицу 4х3 по строкам ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 Список - объект типа list, элементы которого могут быть объектами любого типа Создаётся командой list() list1 &lt;- list(&#39;obj1&#39; = 5:10, &#39;элемент 2&#39; = &#39;текст&#39;, &#39;таблица&#39;=data.frame(a=1:3, b=2:4)) # созданный список записали в переменную list1 list1 # вывели весь список ## $obj1 ## [1] 5 6 7 8 9 10 ## ## $`элемент 2` ## [1] &quot;текст&quot; ## ## $таблица ## a b ## 1 1 2 ## 2 2 3 ## 3 3 4 list1$`элемент 2` # индексация по названию объекта в списке ## [1] &quot;текст&quot; list1[[3]] # индексация по порядковому номеру объекта в списке ## a b ## 1 1 2 ## 2 2 3 ## 3 3 4 data.frame - класс таблиц. столбцы в data.frame могут быть разного типа, но элементы внутри столбца - одного типа. Можно представлять объекты этого класса как список векторов одинаковой длины. Создаётся командой data.frame(). df1 &lt;- data.frame(&quot;col1&quot;=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), col2=2, &#39;col3&#39;=c(F,F,NA)) df1$col1 # знак $ для индексации по колонкам ## [1] a b c ## Levels: a b c df1[c(2,1), c(&#39;col1&#39;, &#39;col2&#39;)] # индексация в квадратных скобках: [ вектор номеров строк , вектор названий колонок ] ## col1 col2 ## 2 b 2 ## 1 a 2 df1[c(F,T,T),] # индексация с помощью логического вектора, выводятся строки с TRUE. Обязательно указываем запятую после индексации по строкам ## col1 col2 col3 ## 2 b 2 FALSE ## 3 c 2 NA class(df1[,1]) # столбец 1 таблицы имеет класс factor - класс для категориальных переменных, с уровнями (возможными значениями) a, b, c ## [1] &quot;factor&quot; 2.5 Некоторые полезные функции Расчётные функции sum(x) - сумма sum(-10:12) ## [1] 23 sum(c(1,2,3,4,NA,5), na.rm=T) # na.rm=T - не обращать внимание на пропуски при вычислении. Применяется во многих подобных функциях ## [1] 15 mean(x) - среднее mean(-10:12) ## [1] 1 mean(c(1,2,3,4,NA,5), na.rm=T) ## [1] 3 min(x), max(x) - минимум, максимум min(-10:12) ## [1] -10 max(c(1,2,3,4,NA,5), na.rm=T) ## [1] 5 log(x, base) - логарифм x по основанию base log(1:5) # без указания основания берётся натуральный логарифм ## [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 log(1:5, base = 5) ## [1] 0.0000000 0.4306766 0.6826062 0.8613531 1.0000000 cor(x, y) - парный коэффициент корреляции между двумя векторами cor(1:5, c(1,1,3,5,5)) ## [1] 0.9486833 var(x) - дисперсия sd(x) - стандартное отклонение median(x) - медиана Работа с данными df2 &lt;- data.frame(col1=c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;, &#39;f&#39;), col2=c(1, 2, 3, 6, 5, 4, 3)) head(x, n), tail(x, n) - первые или последние n элементов объекта x (по умолчанию n = 6) head(df2, 3) ## col1 col2 ## 1 a 1 ## 2 b 2 ## 3 c 3 tail(df2,2) ## col1 col2 ## 6 d 4 ## 7 f 3 summary(x) - вывод основных параметров объекта summary(df2) ## col1 col2 ## a:1 Min. :1.000 ## b:1 1st Qu.:2.500 ## c:1 Median :3.000 ## d:3 Mean :3.429 ## f:1 3rd Qu.:4.500 ## Max. :6.000 length() - длина объекта length(df2$col2) ## [1] 7 nrow(), ncol() - число строк и число стобцов c(nrow(df2), ncol(df2)) ## [1] 7 2 sort() - отсортировать вектор (по умолчанию - по возрастанию) sort(df2$col2) ## [1] 1 2 3 3 4 5 6 sort(df2$col2, decreasing = T) # по убыванию ## [1] 6 5 4 3 3 2 1 order() - возвращает индексы элементов в порядке возрастания order(df2$col2) ## [1] 1 2 3 7 6 5 4 order(df2$col2, decreasing = T) # в подярке убывания ## [1] 4 5 6 3 7 2 1 df2[order(df2$col2, decreasing = T),] # передаём индексы таблице - получаем отсортированную по убыванию *col2* ## col1 col2 ## 4 d 6 ## 5 d 5 ## 6 d 4 ## 3 c 3 ## 7 f 3 ## 2 b 2 ## 1 a 1 table(x) - возвращает таблицу с уникальными значениями вектора x и числом их вхождений table(df2$col1) ## ## a b c d f ## 1 1 1 3 1 sort(table(df2$col1), decreasing = T)[1:3] # сортируем по убыванию и берём топ 3 значений ## ## d a b ## 3 1 1 unique() - возвращает объект с уникальными значениями (без повторений) unique(df2$col2) ## [1] 1 2 3 6 5 4 apply(),lapply(), sapply() - применение функции к каждому элементу объекта. apply применяется к матрицам, таблицам; lapply возвращает список; sapply возвращает вектор lapply(1:5, function(x)x^2) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 4 ## ## [[3]] ## [1] 9 ## ## [[4]] ## [1] 16 ## ## [[5]] ## [1] 25 sapply(1:5, function(x)x^2) ## [1] 1 4 9 16 25 apply(df2, MARGIN = 2, function(x)length(unique(x))) # количество уникальных значений по столбцам. Чтобы применить функцию к строкам, MARGIN = 1 ## col1 col2 ## 5 6 rbind(), cbind() - соединить несколько строк по строкам, столбцам (r- для row, c- для column) rbind(df2, data.frame(col1=&#39;A&#39;, col2=10)) # названия столбцов должны соответствовать ## col1 col2 ## 1 a 1 ## 2 b 2 ## 3 c 3 ## 4 d 6 ## 5 d 5 ## 6 d 4 ## 7 f 3 ## 8 A 10 cbind(df2, data.frame(col3=11:17)) ## col1 col2 col3 ## 1 a 1 11 ## 2 b 2 12 ## 3 c 3 13 ## 4 d 6 14 ## 5 d 5 15 ## 6 d 4 16 ## 7 f 3 17 merge() - объединение двух таблиц по общему ключу Параметр by указывает на наименование столбца с ключами. Если столбцы с ключами для первой и второй таблицы имеют разные названия, они перечисляются отдельно параметрами by.x и by.y для первой и второй таблицы соответственно. По умолчанию в результате остаются только строки, имеющие общие ключи в обеих таблицах: merge(df2, data.frame(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), # создали новую таблицу by=&#39;col1&#39;) # по колонке col1 ## col1 col2 col3 ## 1 a 1 11 ## 2 d 6 15 ## 3 d 5 15 ## 4 d 4 15 ## 5 f 3 13 Если нужно сохранить строки первой или второй таблицы, добавляются параметры all.x=T или all.y=T. На месте, где нет совпадений, появятся пропуски NA merge(df2, data.frame(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), by=&#39;col1&#39;, all.y=T ) ## col1 col2 col3 ## 1 a 1 11 ## 2 d 6 15 ## 3 d 5 15 ## 4 d 4 15 ## 5 f 3 13 ## 6 A NA 20 merge(df2, data.frame(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), by=&#39;col1&#39;, all.x=T, all.y=T ) ## col1 col2 col3 ## 1 a 1 11 ## 2 b 2 NA ## 3 c 3 NA ## 4 d 6 15 ## 5 d 5 15 ## 6 d 4 15 ## 7 f 3 13 ## 8 A NA 20 "]
]
