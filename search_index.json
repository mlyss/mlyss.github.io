[
["index.html", "Методические указания по выполнению расчётно-графической работы в R Раздел 1 Задание на расчётно-графическую работу 1.1 Порядок выполнения работы", " Методические указания по выполнению расчётно-графической работы в R Михаил Лысенко 2020-04-17 Раздел 1 Задание на расчётно-графическую работу Федеральной службой государственной статистики РФ ежеквартально проводятся бюджетные обследования домашних хозяйств по всем регионам России об условиях проживания и уровне благосостояния населения. Необходимо проанализировать данные обследования о расходах и доходах домохозяйств. В рамках работы данные обследований описываются следующими показателями: - код территории по ОКАТО (переменная ТЕРРИТОРИЯ) - тип населенного пункта (переменная ТИПНАС, 1 - город, 2 - село) - расходы на продукты питания (переменная ПРОДПИТ, y(1)) - расходы на непродовольственные товары (переменная НЕПРОД, y(2)) - расходы на оплату услуг (переменная УСЛУГИ, y(3)) - расходы на покупку алкогольной продукции (переменная АЛКО, x0) - доходы домохозяйства (переменная ДОХОД, x1) - сбережения домохозяйства (переменная СБЕРЕЖ, x2) - число людей в домохозяйстве (ЧИСЛОЛЮД, x3) - число детей в домохозяйстве (ЧИСЛОДЕТ, x4) Федеральный округ и отклик y берутся в соответствии с выданным вариантом. Скачать исходные данные 1.1 Порядок выполнения работы 1. Прочитать исходные данные, Исследовать структуру данных: сколько наблюдений, какие поля, какого типа, есть ли пропуски. Исключить отклики y, не соответствующие выданному варианту. 2. Дополнить данные полями из файла codes.xls (скачать): - Код: код региона по ОКАТО, соответствующий переменной ТЕРРИТОРИЯ в данных по обследованиям - Название: название региона - ФО: федеральный округ, к которому относится регион - hc-a2: код региона, соответствующий переменной hc-a2 карты “Russia with disputed territories” библиотеки Highcharter Сколько наблюдений приходится на каждый из федеральных округов? Вывести топ-10 регионов по убыванию количества наблюдений. Вывести топ-10 регионов по убыванию среднего значения отклика y. 3. Рассчитать новую переменную: доход на одного взрослого (x1/(x3-x4)). По полученному показателю Для каждого региона рассчитать среднее арифметическое и медиану. Отобразить полученные значения на карте “Russia with disputed territories” библиотеки Highcharter (с учётом, что в данных по обследованиям ХМАО и ЯНАО относятся к Тюменской области, а Ненецкий АО к Архангельской области). Цветовая шкала в зависимости от среднего, во всплывающем окне выводить название региона, среднее и медиану. Проанализировать результаты, сделать выводы. Как различаются регионы между собой? Отличается ли средний доход от медианного дохода. В связи с чем возникают различия? 4. Отфильтровать данные, оставив наблюдения по федеральному округу в соответствии с вариантом. Отклик На одном рисунке построить корреляционные поля, рассчитать коэффициенты корреляции и распределения между переменными y, x0, x1, x2, x3, x4 (функция ggpairs() библиотеки GGally). Сделать выводы о наличии связи между показателями, её виде и форме. 5. Провести проверку данных на наличие выбросов с удалением всех наблюдений \\(\\overline{x}_{(i)}=(x_{1i},x_{2i})\\), для которых выполняется соотношение \\(h_{i}=\\overline{x}_{(i)}(X^{T}X)^{-1}\\overline{x}_{(i)}^{T}\\geqslant \\frac{3}{N}\\), где \\(X\\) - матрица, составленная из значений переменных x1 и x2. На основе оставшихся наблюдений перестроить корреляционные поля, сделать сравнения. Провести расчет основных выборочных характеристик, проинтерпретировать результаты, сделать выводы. 6. Рассчитать выборочные парные коэффициенты корреляции для всех возможных пар переменных, проверить их на значимость, сделать выводы о тесноте связи между признаками. 7. Построить корреляционное поле между откликом и доходом. Построить линейную модель парной регрессии между этими переменными. Добавить линию регрессии на координатную плоскость. Проанализировать результаты (форма корреляционного поля, что показывают оценки параметров, каково качество модели, выводы о значимости параметров и модели). Проделать то же самое по прологарифмированным переменным. Сделать выводы, что изменилось? Доп. баллы: для двух моделей построить и проанализировать корреляционное поле между доходом и модулем остатков модели. С помощию критерия Голдфельда-Квандта изучить обе модели на наличие гетероскедастичности. Сделать выводы. 8. В модель с логарифмированными переменными добавить факторную переменную ТИПНАС, учитывая взаимодействие этой переменной с величиной дохода. Построить корреляционное поле, новую переменную обозначив цветом. Добавить линии регрессии, проинтерпретировать результаты и сделать выводы. 9. Построить линейную модель множественной регресии по всем входным переменным x0, x1, x2, x3, x4, сделать выводы. Проранжировать входные факторы по степени влияния на отклик при помощи коэффициентов эластичности. Отобрать два наиболее сильно влияющих фактора, изобразить в трёх измерениях модель частной регрессии с этими факторами, заменив медианами значения остальных переменных: добавить исходные данные, плоскость регрессии и плоскости 95% доверительного интервала. Затем построить этот график, прологарифмировав значения отклика, прогнозов и доверительных интервалов. Сделать выводы. 10. Сделать общие выводы по проделанной работе в терминах исходных показателей. Предложить рекомендации по улучшению экономической ситуации в федеральном округе. "],
["intro.html", "Раздел 2 Начало работы 2.1 Установка R и Rstudio, знакомство с рабочей областью 2.2 Типы переменных 2.3 Основные операторы 2.4 Структуры данных", " Раздел 2 Начало работы 2.1 Установка R и Rstudio, знакомство с рабочей областью Скачиваем установочный файл R по ссылке. (кнопка “Download R 3.6.3 for Windows” или более поздняя версия). Запускаем, устанавливаем без изменений. Скачиваем и устанавливаем RStudio с официального сайта. RStudio - среда разработки для языка R, позволяющая работать более комфортно. Запускаем RStudio, создаём новый скрипт: File -&gt; New File -&gt; R Script Рабочая область будет разделена на четыре части. Слева вверху - скрипт, то есть код, написанный и сохранённый в отдельном файле с расширением .R Слева внизу - консоль, в которой отображаются команды и ход их исполнения. Команды можно прописывать и выполнять сразу в консоли Это удобнее делать в случае, если это разовая команда, которую не имеет смысла сохранять в скрипте. Для того, чтобы исполнить команды из скрипта, нужно поставить курсор в нужную строку, либо выдалить нужную часть скрипта и нажать Ctrl+Enter. Справа вверху - рабочая среда (Environment) - список всех объектов, с которыми можно работать. Изначально он будет пуст. Справа внизу обычно выводятся графики (вкладка Plots), справка о функциях (вкладка Help), список установленных библиотек (Packages). Пример: В консоль было введено 2*5 и там же получен результат исполнения - 10. Затем был выделен и запущен скрипт из верхней области: переменной a присвоен (команда &lt;-) результат выражения 9/3, переменная появилась в рабочем пространстве справа. Повторный вызов переменной a выводит в консоль сохранённое значение - 3. Затем был построен график, результат исполнения команды отобразился в нижнем правом углу во вкладке Plots. При работе полезно использовать кнопку Tab, чтобы вызывать окно с подсказками Комментарии в скрипте можно записывать после символа #. Комментарии не исполняются и нужны для создания пометок внутри кода Видео Б.Демешева “Запуск R в первый раз. Консольный режим в R” 2.2 Типы переменных Чтобы узнать тип переменной, используется функция class() NA - переменная для пропущенного значения (Not Available) Основные типы переменных: Логические (TRUE, T, FALSE, F) class(TRUE) # TRUE, T - истина; FALSE, F - ложь # [1] &quot;logical&quot; Числовые (4, -5.5, 100, 1.2e+10, Inf, -Inf, NaN) NaN - “Not a Number” - получается в результате некоторых операций, напр. квадратного корня из (-1). Подробнее class(5.22e+3) # экспоненциальная запись, = 5.22*10^3 = 5220 # [1] &quot;numeric&quot; class(-Inf) # минус бесконечность # [1] &quot;numeric&quot; Текстовые (\"ch\", \"10\", ' - ', '') class(&#39;&#39;) # записываются в одинарных либо двойных кавычках # [1] &quot;character&quot; Менять тип переменных можно с помощью функций: as.logical() as.logical(-595) # число 0 меняется на FALSE, остальные числа - на TRUE # [1] TRUE as.logical(&quot;F&quot;) # [1] FALSE as.numeric() as.numeric(&#39;950&#39;) # [1] 950 as.numeric(T) # TRUE меняется на число 1, FALSE на 0 # [1] 1 as.character() as.character(10) # [1] &quot;10&quot; as.character(FALSE) # [1] &quot;FALSE&quot; 2.3 Основные операторы Математические: +, -, *, /, ^ - сложение, вычитание, умножение, деление, возведение в степень (2*3+8/2)^(5-3) # [1] 100 Сравнения: &lt;, &gt;, &lt;=, &gt;=, ==, != - меньше, больше, меньше либо равно, больше либо равно, равно, не равно Результат - логическая переменная TRUE или FALSE 10&lt;=5 # сравнение чисел # [1] FALSE 0==FALSE # FALSE заменяется на 0, TRUE на 1 # [1] TRUE &#39;faf&#39;&lt;&#39;fb&#39; # текстовые переменые сравниваются по алфавиту, цифры считаются меньше букв # [1] TRUE Логические: &amp;, |, ! - И, ИЛИ, НЕ TRUE &amp; (1&gt;0) &amp; (&#39;faf&#39;!=&#39;ga&#39;) # TRUE, если все составляющие тоже TRUE. При одном FALSE всё выражение FALSE # [1] TRUE (2==22) | (5&gt;2) | (F) # TRUE, если хотя бы одно из составляющих TRUE. Иначе FALSE # [1] TRUE !(1&gt;0) # отрицание, F меняется на T и наоборот # [1] FALSE Преобразование матриц %*% - умножение матриц matrix(2,4,6)%*%matrix(3,6,2) # [,1] [,2] # [1,] 36 36 # [2,] 36 36 # [3,] 36 36 # [4,] 36 36 t() - транспонирование матрицы t(matrix(2,4,6)%*%matrix(3,6,2)) # транспонируем из примера выше # [,1] [,2] [,3] [,4] # [1,] 36 36 36 36 # [2,] 36 36 36 36 solve() - нахождение обратной матрицы solve(matrix(c(3,6,5,8,4,3,2,4,5), 3, 3)) # [,1] [,2] [,3] # [1,] -0.13333333 0.56666667 -0.4 # [2,] 0.16666667 -0.08333333 0.0 # [3,] 0.03333333 -0.51666667 0.6 %in% - есть ли значение слева от оператора в наборе значений справа 5 %in% c(2,5,3,NA) # 5 есть в векторе справа # [1] TRUE c(1,2, NA) %in% c(2,3,4,NA) # 1 нет, 2 есть, NA есть # [1] FALSE TRUE TRUE Видео Б.Демешева “Написание первого скрипта в R” 2.4 Структуры данных Вектор - последовательность значений, все элементы вектора должны быть одного типа (числовые, текстовые и т д). Создаётся с помощью оператора c(), внутри которого, через запятую, перечисляются элементы вектора c(-2, Inf, NA, 1000) # [1] -2 Inf NA 1000 c(&#39;aa&#39;, &#39;B&#39;, NA) # [1] &quot;aa&quot; &quot;B&quot; NA c(F,F,T) # [1] FALSE FALSE TRUE Некоторые способы создания: С помощью оператора : , который создаёт последовательность чисел от числа слева до числа справа с шагом в единицу -5:5 # [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 2.7:8.5 # [1] 2.7 3.7 4.7 5.7 6.7 7.7 Функция rep() - реплицирует (копирует) первый аргумент столько раз, сколько указано во втором аргументе rep(NA, 5) # [1] NA NA NA NA NA rep(&quot; - &quot;, 10) # [1] &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; &quot; - &quot; Функция seq() - создаёт последовательность чисел от минимального (аргумент 1) до максимального (аргумент 2) с шагом, равным аргументу 3 seq(1,100,22) # [1] 1 23 45 67 89 seq(15,-20,-4) # [1] 15 11 7 3 -1 -5 -9 -13 -17 Способы можно комбинировать rep(c(-Inf,5:8,NaN), 3) # [1] -Inf 5 6 7 8 NaN -Inf 5 6 7 8 NaN -Inf 5 6 # [16] 7 8 NaN Матрица (двумерная) - набор данных, имеющий два измерения. Все элементы матрицы должны быть одного типа. Создаётся путём указания вектора значений, которые последовательно распределяются по заданным размерностям матрицы (по умолчанию заполняется по колонкам) matrix(1:6, 2, 3) # вектор от 1 до 6 распределяем на матрицу 2х3 по колонкам # [,1] [,2] [,3] # [1,] 1 3 5 # [2,] 2 4 6 matrix(1:12, 4, 3, byrow = T) # вектор от 1 до 12 распределяем на матрицу 4х3 по строкам # [,1] [,2] [,3] # [1,] 1 2 3 # [2,] 4 5 6 # [3,] 7 8 9 # [4,] 10 11 12 Список - объект типа list, элементы которого могут быть объектами любого типа Создаётся командой list() list1 &lt;- list(&#39;obj1&#39; = 5:10, &#39;элемент 2&#39; = &#39;текст&#39;, &#39;таблица&#39;=data.frame(a=1:3, b=2:4)) # созданный список записали в переменную list1 list1 # вывели весь список # $obj1 # [1] 5 6 7 8 9 10 # # $`элемент 2` # [1] &quot;текст&quot; # # $таблица # a b # 1 1 2 # 2 2 3 # 3 3 4 list1$`элемент 2` # индексация по названию объекта в списке # [1] &quot;текст&quot; list1[[3]] # индексация по порядковому номеру объекта в списке # a b # 1 1 2 # 2 2 3 # 3 3 4 Таблицы data.frame - класс таблиц. столбцы в data.frame могут быть разного типа, но элементы внутри столбца - одного типа. Можно представлять объекты этого класса как список векторов одинаковой длины. Создаётся командой data.frame(). df1 &lt;- data.frame(col1=c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;d&#39;,&#39;d&#39;,&#39;e&#39;,&#39;e&#39;), col2=2, col3=c(4,7,5.5,3,9,0,9,5)) df1$col1 # знак $ для индексации по колонкам # [1] a b c d d d e e # Levels: a b c d e df1[c(2,1), c(&#39;col1&#39;, &#39;col2&#39;)] # индексация в квадратных скобках: [ вектор номеров строк , вектор названий колонок ] # col1 col2 # 2 b 2 # 1 a 2 df1[c(F,T,T,F,T,F,F,F),] # индексация с помощью логического вектора, выводятся строки с TRUE. Обязательно указываем запятую после индексации по строкам # col1 col2 col3 # 2 b 2 7.0 # 3 c 2 5.5 # 5 d 2 9.0 df1[df1$col1 %in% c(&#39;b&#39;, &#39;d&#39;),] # df1$col1 %in% c(&#39;b&#39;, &#39;d&#39;) возвращает логический вектор, указывая, где в col1 находятся &#39;b&#39; или &#39;d&#39; # col1 col2 col3 # 2 b 2 7 # 4 d 2 3 # 5 d 2 9 # 6 d 2 0 # логический вектор используется для индексации как в примере с data.frame class(df1[,1]) # столбец 1 таблицы имеет класс factor - класс для категориальных переменных, с уровнями (возможными значениями) a, b, c # [1] &quot;factor&quot; data.table - класс таблиц одноимённого пакета. По сути, это улучшенная версия data.frame. Об установке и использовании библиотек говорится в разделе 3. library(data.table) dt1 &lt;- as.data.table(df1) class(dt1) # это также и data.frame # [1] &quot;data.table&quot; &quot;data.frame&quot; В квадратных скобках после data.table можно выполнять гораздо больше задач, чем в data.frame Область внутри квадратных скобок делится на 3 части запятыми: [выбор строк , выбор и преобразование столбцов , группировка по признаку] Строки можно выбирать с помощью номеров строк, логическими векторами, аналогично data.frame В data.table переменная .N содержит в себе количество строк в таблице (либо в группе, если применяется группировка) dt1[(.N-2):.N] # выбраны последние 3 строки # col1 col2 col3 # 1: d 2 0 # 2: e 2 9 # 3: e 2 5 Выбирать строки по условиям (напр, где в col1 содержится ‘b’ или ‘d’), немного удобнее, чем в data.frame: dt1[col1 %in% c(&#39;b&#39;, &#39;d&#39;)] # после выбора строк не обязательно прописывать запятую, как требуется в data.frame # col1 col2 col3 # 1: b 2 7 # 2: d 2 3 # 3: d 2 9 # 4: d 2 0 dt1[col1==&#39;d&#39; &amp; col3&gt;=3] # можно комбинировать несколько условий # col1 col2 col3 # 1: d 2 3 # 2: d 2 9 Во второй части квадратных скобок производятся операции над столбцами. Простое указание названия столбца возвращает столбец в виде вектора: dt1[ , col2] # поскольку выбор строк не осуществлялся, первая область перед запятой осталась пустой # [1] 2 2 2 2 2 2 2 2 Чтобы вернуть столбец или несколько столбцов как data.table, названия нужно перечислять списком, внутри list() или .() (в data.table .() эквивалентен списку, более удобен в использовании) dt1[col3&gt;=6 , list(col1)] # col1 # 1: b # 2: d # 3: e dt1[col1==&#39;e&#39; , .(col2, col3)] # col2 col3 # 1: 2 9 # 2: 2 5 Для преобразования столбцов используется оператор :=. С его помощью можно изменять текущие, создавать новые, удалять столбцы. dt1[,col1:=as.character(col1)] # изменим тип столбца с factor на character dt1[,class(col1)] # [1] &quot;character&quot; dt1[,col4:=col3^col2] # создаём новый столбец, в котором будет результат возведения значения в col3 в степень из col2 dt1[,col2:=NULL] # NULL - нулевой, несуществующий объект. col2 будет удалён dt1 # col1 col3 col4 # 1: a 4.0 16.00 # 2: b 7.0 49.00 # 3: c 5.5 30.25 # 4: d 3.0 9.00 # 5: d 9.0 81.00 # 6: d 0.0 0.00 # 7: e 9.0 81.00 # 8: e 5.0 25.00 В третьей части квадратных скобок указывается, по какому столбцу (столбцам) производить группировку dt1[,.N,col1] # сколько в таблице строк для каждого уникального значения из col1 # col1 N # 1: a 1 # 2: b 1 # 3: c 1 # 4: d 3 # 5: e 2 dt1[col3&gt;3, .(mean_col4=mean(col4)),col1] # выбираем только строки с col3&gt;3, по ним рассчитываем средний col4 для каждого значения из col1 # col1 mean_col4 # 1: a 16.00 # 2: b 49.00 # 3: c 30.25 # 4: d 81.00 # 5: e 53.00 # новый столбец назовём mean_col4, выражение mean_col4=mean(col4) обернём в список .() Можно группировать по нескольким столбцам, перечисляя их в списке .(). Тогда будет возвращён результат для каждой уникальной связки значений этих переменных dt1[, .(quantity=.N),.(col1,col3)] # для каждой уникальной пары значений col1 и col3 подсчитаем, сколько присутствует наблюдений # col1 col3 quantity # 1: a 4.0 1 # 2: b 7.0 1 # 3: c 5.5 1 # 4: d 3.0 1 # 5: d 9.0 1 # 6: d 0.0 1 # 7: e 9.0 1 # 8: e 5.0 1 # результат - везде 1, так как в исходной таблице нет повторяющихся комбинации значений col1 и col3 Далее в методичке для всех таблиц будет использоваться класс data.table Руководство по data.table (на русском языке) "],
["functions.html", "Раздел 3 Пакеты и функции 3.1 Функции в R 3.2 Некоторые полезные функции 3.3 Функция lm() для моделей регрессии 3.4 Пакеты", " Раздел 3 Пакеты и функции 3.1 Функции в R Функцией можно назвать именованный фрагмент кода, который принимает на вход некоторые параметры (аргументы функции), производит некоторые операции. Большинство функций возвращают результат, однако некоторые могут только выполнять операции, ничего не возвращая. Существуют базовые функции, которые встроены в стандартные пакеты R (о пакетах будет сказано далее). Можно использовать функции, которые содержатся в сторонних пакетах, предварительно установив и загрузив нужный пакет. Также есть возможность создавать собственные функции. Чтобы вывести справку по функции, можно ввести в консоль ? и название функции Например: ?mean Некоторые аргументы функции могут иметь значения по умолчанию. Рассмотрим функцию mean стандартного пакета base, которая рассчитывает среднее арифметическое по заданному набору чисел. Аргументы функции: - x - объект, по которому ведётся расчёт среднего - trim = 0 - доля наблюдений, исключаемая из начала и из конца упорядоченного вектора x перед расчётом среднего. По умолчанию равна 0 - na.rm = FALSE - логический аргумент, указывающий, должны (T) или нет (F) быть исключены пропуски NA перед расчётом среднего. По умолчанию пропуски не исключаются Примеры использования: mean(x = c(1,100,5,5,5)) # [1] 23.2 mean(x = c(1,100,5,5,5), trim = 0.2) # исключено 20% минимальных и 20% максимальных значений # [1] 5 mean(x = c(1,100,5,5,5,NA,NA,NA,NA), trim = 0.2) # по умолчанию пропуски не игнорируются # [1] NA mean(x = c(1,100,5,5,5,NA,NA,NA,NA), trim = 0.2, na.rm = T) # игнорировать пропуски # [1] 5 Функцию можно записывать и не указывая названия аргумента, но тогда значения должны идти в том порядке, в котором они шли при создании функции Например, порядок аргументов для mean: x, trim, na.rm: mean(c(1,100,5,5,5,NA,NA,NA,NA), 0.2, T) # аналогичный результат # [1] 5 Попробуем поменять местами значения для x и trim: mean(0.2, c(1,100,5,5,5,NA,NA,NA,NA), T) # ошибка # Error in mean.default(0.2, c(1, 100, 5, 5, 5, NA, NA, NA, NA), T): &#39;trim&#39; must be numeric of length one Укажем название только для того аргумента, который стоит не по порядку: mean(trim = 0.2, c(1,100,5,5,5,NA,NA,NA,NA), T) # [1] 5 Создание собственных функций Общая схема для собственной функции: имя_функции &lt;- function(аргументы) { код с вычислениями return(возвращаемый_объект) } Фигурные скобки можно не использовать, если в теле функции только одно действие return() можно не прописывать, если возвращаемый объект вызывается в конце функции Например, создадим и используем функцию, которая возводит число в указанную степень (по умолчанию 2) powerN &lt;- function(x, N = 2) x^N powerN(5) # [1] 25 powerN(5,3) # [1] 125 Пример функции, которая рассчитывает коэффициент вариации: CV &lt;- function(x) { mean &lt;- mean(x, na.rm = T) sd &lt;- sd(x, na.rm = T) # стандартное отклонение return(sd/mean) } CV(5:20) # [1] 0.3808762 Видео Б.Демешева “Как написать функцию в R?” 3.2 Некоторые полезные функции Шпаргалка с основными операторами, функциями, командами (на английском языке) Расчётные функции sum(x) - сумма sum(-10:12) # [1] 23 sum(c(1,2,3,4,NA,5), na.rm=T) # na.rm=T - не обращать внимание на пропуски при вычислении. Применяется во многих подобных функциях # [1] 15 mean(x) - среднее mean(-10:12) # [1] 1 mean(c(1,2,3,4,NA,5), na.rm=T) # [1] 3 min(x), max(x) - минимум, максимум min(-10:12) # [1] -10 max(c(1,2,3,4,NA,5), na.rm=T) # [1] 5 log(x, base) - логарифм x по основанию base log(1:5) # без указания основания берётся натуральный логарифм # [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 log(1:5, base = 5) # [1] 0.0000000 0.4306766 0.6826062 0.8613531 1.0000000 cor(x, y) - парный коэффициент корреляции между двумя векторами cor(1:5, c(1,1,3,5,5)) # [1] 0.9486833 var(x) - дисперсия sd(x) - стандартное отклонение median(x) - медиана Работа с данными dt2 &lt;- data.table(col1=c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;, &#39;f&#39;), col2=c(1, 2, 3, 6, 5, 4, 3)) head(x, n), tail(x, n) - первые или последние n элементов объекта x (по умолчанию n = 6) head(dt2, 3) # col1 col2 # 1: a 1 # 2: b 2 # 3: c 3 tail(dt2,2) # col1 col2 # 1: d 4 # 2: f 3 summary(x) - вывод основных параметров объекта summary(dt2) # col1 col2 # Length:7 Min. :1.000 # Class :character 1st Qu.:2.500 # Mode :character Median :3.000 # Mean :3.429 # 3rd Qu.:4.500 # Max. :6.000 length() - длина объекта length(dt2[,col2]) # [1] 7 nrow(), ncol() - число строк и число стобцов c(nrow(dt2), ncol(dt2)) # [1] 7 2 sort() - отсортировать вектор (по умолчанию - по возрастанию) sort(dt2[,col2]) # [1] 1 2 3 3 4 5 6 sort(dt2[,col2], decreasing = T) # по убыванию # [1] 6 5 4 3 3 2 1 order() - возвращает индексы элементов в порядке возрастания order(dt2[,col2]) # [1] 1 2 3 7 6 5 4 order(dt2[,col2], decreasing = T) # в порядке убывания # [1] 4 5 6 3 7 2 1 dt2[order(col2, decreasing = T)] # передаём индексы таблице - получаем отсортированную по убыванию col2 # col1 col2 # 1: d 6 # 2: d 5 # 3: d 4 # 4: c 3 # 5: f 3 # 6: b 2 # 7: a 1 table(x) - возвращает таблицу с уникальными значениями вектора x и числом их вхождений table(dt2[,col1]) # # a b c d f # 1 1 1 3 1 sort(table(dt2[,col1]), decreasing = T)[1:3] # сортируем по убыванию и берём топ 3 значений # # d a b # 3 1 1 unique() - возвращает объект с уникальными значениями (без повторений) unique(dt2[,col2]) # [1] 1 2 3 6 5 4 apply(),lapply(), sapply() - применение функции к каждому элементу объекта. apply применяется к матрицам, таблицам; lapply возвращает список; sapply возвращает вектор lapply(1:5, function(x)x^2) # [[1]] # [1] 1 # # [[2]] # [1] 4 # # [[3]] # [1] 9 # # [[4]] # [1] 16 # # [[5]] # [1] 25 sapply(1:5, function(x)x^2) # [1] 1 4 9 16 25 apply(dt2, MARGIN = 2, function(x)length(unique(x))) # количество уникальных значений по столбцам. Чтобы применить функцию к строкам, MARGIN = 1 # col1 col2 # 5 6 rbind(), cbind() - соединить несколько таблиц по строкам, столбцам (r- для row, c- для column) rbind(dt2, data.table(col1=&#39;A&#39;, col2=10)) # названия столбцов в таблицах должны соответствовать друг другу # col1 col2 # 1: a 1 # 2: b 2 # 3: c 3 # 4: d 6 # 5: d 5 # 6: d 4 # 7: f 3 # 8: A 10 cbind(dt2, data.table(col3=11:17)) # col1 col2 col3 # 1: a 1 11 # 2: b 2 12 # 3: c 3 13 # 4: d 6 14 # 5: d 5 15 # 6: d 4 16 # 7: f 3 17 merge() - объединение двух таблиц по общему ключу Параметр by указывает на наименование столбца с ключами. Если столбцы с ключами для первой и второй таблицы имеют разные названия, они перечисляются отдельно параметрами by.x и by.y для первой и второй таблицы соответственно. По умолчанию в результате остаются только строки, имеющие общие ключи в обеих таблицах: merge(dt2, data.table(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), # создали новую таблицу by=&#39;col1&#39;) # по колонке col1 # col1 col2 col3 # 1: a 1 11 # 2: d 6 15 # 3: d 5 15 # 4: d 4 15 # 5: f 3 13 Если нужно сохранить строки первой или второй таблицы, добавляются параметры all.x=T или all.y=T. На месте, где нет совпадений, появятся пропуски NA merge(dt2, data.table(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), by=&#39;col1&#39;, all.y=T ) # col1 col2 col3 # 1: A NA 20 # 2: a 1 11 # 3: d 6 15 # 4: d 5 15 # 5: d 4 15 # 6: f 3 13 merge(dt2, data.table(col1=c(&#39;a&#39;, &#39;f&#39;, &#39;d&#39;, &#39;A&#39;), col3=c(11,13,15,20)), by=&#39;col1&#39;, all.x=T, all.y=T ) # col1 col2 col3 # 1: A NA 20 # 2: a 1 11 # 3: b 2 NA # 4: c 3 NA # 5: d 6 15 # 6: d 5 15 # 7: d 4 15 # 8: f 3 13 3.3 Функция lm() для моделей регрессии Для построения линейных моделей как парной, так и множественной регрессии, можно использовать функцию lm() Основные аргументы функции: - data - таблица или список, содержащие исходныме данные - formula - формула, описывающая общий вид модели. Записывается в виде: имя зависимой переменной ~ разделённые знаком + имена независимых переменных Например, для модели \\(y_{i}=\\theta _{0}+\\theta _{1}x_{i1}+\\theta _{2}x_{i2}+\\varepsilon _{i}\\) фурмула будет иметь вид y ~ x1 + x2 (где y, x1, x2 - имена переменных в соответствии с исходными данными) Построим линейные модели для следующего набора данных: dt3 &lt;- data.table(y = c(60.323,61.122,60.171,61.187,63.221,63.639,64.989,63.761,66.019,67.857,68.169,66.513,68.655,69.564,69.331,70.551), x1 = c(83,88.5,88.2,89.5,96.2,98.1,99,100,101.2,104.6,108.4,110.8,112.6,114.2,115.7,116.9), x2 = c(107.608,108.632,109.773,110.929,112.075,113.27,115.094,116.219,117.388,118.734,120.445,121.95,123.366,125.368,127.852,130.081), x3=c(rep(&#39;a&#39;, 8),rep(&#39;b&#39;, 8)) ) dt3 # y x1 x2 x3 # 1: 60.323 83.0 107.608 a # 2: 61.122 88.5 108.632 a # 3: 60.171 88.2 109.773 a # 4: 61.187 89.5 110.929 a # 5: 63.221 96.2 112.075 a # 6: 63.639 98.1 113.270 a # 7: 64.989 99.0 115.094 a # 8: 63.761 100.0 116.219 a # 9: 66.019 101.2 117.388 b # 10: 67.857 104.6 118.734 b # 11: 68.169 108.4 120.445 b # 12: 66.513 110.8 121.950 b # 13: 68.655 112.6 123.366 b # 14: 69.564 114.2 125.368 b # 15: 69.331 115.7 127.852 b # 16: 70.551 116.9 130.081 b Построим модель парной регрессии вида \\(y_{i}=\\theta _{0}+\\theta _{1}x_{i}+\\varepsilon _{i}\\), результат занесем в переменную lm1: lm1 &lt;- lm(data = dt3, formula = y ~ x1) class(lm1) # В результате выполнения функции был получен объект класса lm # [1] &quot;lm&quot; lm1 # # Call: # lm(formula = y ~ x1, data = dt3) # # Coefficients: # (Intercept) x1 # 33.189 0.316 При простом вызове объекта отображается Call - какая функция с какими параметрами была использована для создания модели; Coefficients: - оценки параметров модели ((Intercept) соответствует \\(\\widehat{\\theta }_{0}\\), x1 соответствует \\(\\widehat{\\theta }_{1}\\)) Для вывода расширенной сводной статистики (отчёта) по модели используется функция summary(): summary(lm1) # # Call: # lm(formula = y ~ x1, data = dt3) # # Residuals: # Min 1Q Median 3Q Max # -1.68522 -0.44820 -0.07106 0.57166 1.61777 # # Coefficients: # Estimate Std. Error t value Pr(&gt;|t|) # (Intercept) 33.18917 2.12919 15.59 3.06e-10 *** # x1 0.31597 0.02083 15.17 4.39e-10 *** # --- # Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # # Residual standard error: 0.8706 on 14 degrees of freedom # Multiple R-squared: 0.9426, Adjusted R-squared: 0.9385 # F-statistic: 230.1 on 1 and 14 DF, p-value: 4.389e-10 Coefficients: - наряду с оценками переметров выводит их стандартные ошибки (Std. Error); t-статистику для проверки основной гипотезы о равенстве параметра нулю (t value); p-значение (Pr(&gt;|t|)), можно интерпретировать как минимальное значение ошибки, с которой можно отклонить основной гипотезу, либо как уровень ошибки, при котором критическое (табличное) t будет равно расчётному. Multiple R-squared - коэффициент детерминации F-statistic - расчётное значение статистики Фишера p-value - вероятность ошибки, при которой критическое значение F-статистики равно расчётному К объекту с моделью можно применить следующие полезные функции: coef() - возвращает именованный вектор с оценками параметров модели coef(lm1) # (Intercept) x1 # 33.1891734 0.3159661 residuals() - возвращает вектор остатками модели residuals(lm1) # 1 2 3 4 5 6 # 0.90864145 -0.03017202 -0.88638220 -0.28113811 -0.36411089 -0.54644645 # 7 8 9 10 11 12 # 0.51918407 -1.02478202 0.85405868 1.61777399 0.72910286 -1.68521575 # 13 14 15 16 # -0.11195471 0.29149956 -0.41544957 0.42539112 fitted() - возвращает вектор с прогнозными значениями отклика fitted(lm1) # 1 2 3 4 5 6 7 8 # 59.41436 61.15217 61.05738 61.46814 63.58511 64.18545 64.46982 64.78578 # 9 10 11 12 13 14 15 16 # 65.16494 66.23923 67.43990 68.19822 68.76695 69.27250 69.74645 70.12561 predict() - рассчитывает прогноз для заданных значений независимых переменных. Аргумент newdata принимает таблицу со значениями регрессоров, по которым необходимо построить прогноз predict(lm1, newdata = data.table(x1=c(105,107,110))) # 1 2 3 # 66.36561 66.99754 67.94544 С помощью predict() можно построить прогноз с доверительным интервалом, при вызове указав interval=\"prediction\". Уровень доверительной вероятности задаёт аргумент level (по умолчанию level=0.95). Результат - матрица, в которой столбец fit - прогноз, lwr - нижняя граница, upr - верхняя граница интервала predict(lm1, data.table(x1=c(105,107,110)), interval=&quot;prediction&quot;) # fit lwr upr # 1 66.36561 64.43518 68.29605 # 2 66.99754 65.05820 68.93689 # 3 67.94544 65.98516 69.90573 Видео Б.Демешева “МНК в R. Пример с машинами” Построим модель множественный регрессии по всем независимым переменным (x3 - категориальная переменная). lm2 &lt;- lm(data = dt3, formula = y ~ x1+x2+factor(x3)) # сменили класс x3 на factor. Делать обязательно, если х3 имеет класс integer. summary(lm2) # # Call: # lm(formula = y ~ x1 + x2 + factor(x3), data = dt3) # # Residuals: # Min 1Q Median 3Q Max # -1.78912 -0.36333 0.08981 0.38741 1.13530 # # Coefficients: # Estimate Std. Error t value Pr(&gt;|t|) # (Intercept) 34.78778 9.15880 3.798 0.00254 ** # x1 0.21265 0.09659 2.202 0.04800 * # x2 0.06963 0.15034 0.463 0.65156 # factor(x3)b 1.46182 0.77780 1.879 0.08468 . # --- # Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # # Residual standard error: 0.8099 on 12 degrees of freedom # Multiple R-squared: 0.9575, Adjusted R-squared: 0.9468 # F-statistic: 90.03 on 3 and 12 DF, p-value: 1.706e-08 Получены статистики, аналогичные модели парной регрессии. Отличительная особенность модели - оценка параметра при переменной x3. factor(x3)b можно проинтерпретировать как величину, на которую изменится прогноз отклика, если x3 примет значение b. Видео Б.Демешева “МНК в R. Пример с фертильностью (swiss)” Рассмотрим, как строить модели с логарифмированной переменной, со взаимодействием какого-либо регрессора с факторным регрессором, а также как интерпретировать коэффициенты в таких моделях Построим модель. Логарифмировать переменные можно при задании формулы с помощью log(). Взаимодействие x1 и x3 отображается с помощью :. lm3 &lt;- lm(data = dt3, formula = log(y) ~ x1+x2+factor(x3)+x1:factor(x3)) summary(lm3) # # Call: # lm(formula = log(y) ~ x1 + x2 + factor(x3) + x1:factor(x3), data = dt3) # # Residuals: # Min 1Q Median 3Q Max # -0.023725 -0.005650 0.002457 0.007550 0.014058 # # Coefficients: # Estimate Std. Error t value Pr(&gt;|t|) # (Intercept) 3.533598 0.209379 16.877 3.28e-09 *** # x1 0.003080 0.001520 2.027 0.0676 . # x2 0.002794 0.002879 0.971 0.3525 # factor(x3)b 0.210507 0.144481 1.457 0.1731 # x1:factor(x3)b -0.001851 0.001416 -1.307 0.2178 # --- # Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # # Residual standard error: 0.01219 on 11 degrees of freedom # Multiple R-squared: 0.9626, Adjusted R-squared: 0.9491 # F-statistic: 70.87 on 4 and 11 DF, p-value: 8.846e-08 Интерпретация параметров оценок параметров при x1, x2: - x1: 0.003080 - при увеличении x1 на 1, y увеличится на 0.0031*100% = 0.31 % - x2: 0.002794 - при увеличении x2 на 1, y увеличится на 0.0028*100% = 0.28 % - factor(x3)b: 0.210507 - если x3 примет значение b, log(y) увеличится на 0.211, или y увеличится на exp(0.211) = 1.235 - x1:factor(x3)b: -0.001851 - если x3 примет значение b, коэффициент при x1 уменьшится на 0.002 По построенной модели найдём прогноз отклика при x1 = 105, x2 = 115, x3 = 'b' Рассчитаем прогноз log(y) по найденным оценкам параметров: 3.533598 + (0.003080 - 0.001851)*105 + 0.002794*115 + 0.210507 # [1] 4.19446 Найдём прогноз log(y) при тех же значениях независимых переменных с помощью predict() predict(lm3, data.table(x1 = 105, x2 = 115, x3 = &#39;b&#39;)) # 1 # 4.19457 Расхождения появились вследствие того, что в первом случае оценки параметров округлялись. Прогноз без округления: coef(lm3)[1] + (coef(lm3)[2] + coef(lm3)[5])*105 + coef(lm3)[3]*115 + coef(lm3)[4] # (Intercept) # 4.19457 Значения сходятся. Найдем прогноз y: exp(4.19457) # [1] 66.32521 Видео Б.Демешева “Интерпретация коэффициента при логарифмировании в уравнениях регрессии” 3.4 Пакеты Пакет - набор функций и наборов данных. Существуют стандартные пакеты, которые доступны сразу после установки R и позволяют R работать (например, base, stats, methods, utils). Также существуют сторонние пакеты, написанные различными авторами (например, data.table, который уже использовался нами ранее). Установить пакет можно с помощью команды install.packages(), внутри которой указывается название пакета в кавычках. Можно устанавливать пакеты с помощью интерфейса RStudio: Tools -&gt; Install Packages… или Install вкладки с пакетами Для использования пакета нужно его загрузить в текущую рабочую сессию с помощью функции library() library(data.table) Если пакетом нужно воспользоваться единожды, можно воспользоваться оператором ::, не загружая пакет (но быть установлен он должен). Перед :: указывается название пакета, после - вызываемая команда. Например: data.table::shift(1:10, 2) # функция сдвигает вектор, в данном случае на 2 шага вправо # [1] NA NA 1 2 3 4 5 6 7 8 В случае, если требуется указать, в какую директорию нужно установить пакет, можно использовать функцию install.packages(), в аргументе lib указав путь к нужной папке. Это может быть полезно в случае, если имя учётной записи компьютера содержит кириллицу, что вызывает ошибки при установке пакетов. В таком случае пакеты нужно устанавливать в папку, путь к которой не содержит кириллицы. Например: install.packages(\"data.table\", lib=\"C:/R/packages\") При загрузке пакетов также указывается путь к папке с помощью аргумента lib.loc: library(\"data.table\", lib.loc=\"C:/R/packages\") Список доступных пакетов на CRAN\" Для каждого из пакетов имеется документация (“Reference manual”), с помощью которой можно подробнее ознакомиться с пакетом, в том числе с доступными функциями Например, документация по data.table Список сторонних пакетов, которые могут помочь в выполнении РГР: data.table - для работы с таблицами readxl - для чтения файлов с исходными данными в формате .xls, .xlsx Hmisc - имеется функция rcorr() для расчёта коэффициентов корреляции с проверкой значимости GGally - имеется функция ggpairs() для построения корреляционных полей между набором показателей psych - функция pairs.panels() для построения корреляционных полей, коэффициентов корреляции распределений переменных e1071 - функции skewness() и kurtosis() для расчёта коэффициентов асимметрии и эксцесса broom - функция augment для построения таблицы с исходными данными, прогнозами, остатками и другими показателями на основе модели регрессии ggplot2 - один из самых популярных пакетов для визуализации данных highcharter - пакет для создания интерактивных графиков plotly - позволяет строить трехмерные интерактивные графики Чтобы прочитать данные из документов в формате .xls, .xlsx, используем функции read_xls(), read_xlsx() пакета readxl. В аргумент path нужно передать в кавычках путь к файлу, включая название самого файла с его расширением. Можно указывать полный путь к документу, например, 'C:/Users/Mihail/Documents/rgr_econometrics/_book/rgr_econometrics_files/codes.xls' (нужно использовать прямые слеши /) Можно указывать неполный путь, начиная от текущей рабочей директории. Функция getwd() позволяет узнать, какая директория является текущей. setwd() позволяет установыить другую директорию в качестве текущей. getwd() # [1] &quot;C:/Users/Mihail/Documents/rgr_econometrics&quot; В аргумент sheet можно передать номер листа, с которого нужно считать данные в документе. По умолчанию читается первый лист Посмотрим, объектом какого класса является результат выполнения функции: xlsx1 &lt;- readxl::read_xlsx(&#39;_book/rgr_econometrics_files/01 ДАННЫЕ для РГР-ФБЭ.xlsx&#39;) class(xlsx1) # [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; В результате чтения была получена таблица другого класса - tibble. Используем функцию as.data.table(), чтобы конвертировать таблицу в data.table: xlsx1 &lt;- as.data.table(xlsx1) class(xlsx1) # [1] &quot;data.table&quot; &quot;data.frame&quot; "],
["graphics.html", "Раздел 4 Визуализация данных 4.1 Стандартные методы 4.2 Пакет ggplot2 4.3 Пакет highcharter", " Раздел 4 Визуализация данных Рассмотрим способы визуализации на сгенерированном наборе данных: dt4 &lt;- data.table(id = 1:16, y = seq(60,by = 0.5, length.out = 16)+rnorm(16, 0, 1), x1 = seq(80,by = 1, length.out = 16)+rnorm(16, 0, 3), x2 = seq(100,by = 3, length.out = 16)+rnorm(16, 0, 5), x3=c(rep(&#39;a&#39;, 8),rep(&#39;b&#39;, 8)) ) dt4 # id y x1 x2 x3 # 1: 1 60.67591 79.21969 92.26569 a # 2: 2 61.72452 80.58171 108.15305 a # 3: 3 61.92236 82.87583 102.37141 a # 4: 4 61.79400 85.93679 97.92914 a # 5: 5 62.81729 82.87147 106.10911 a # 6: 6 62.80943 82.69275 103.06020 a # 7: 7 62.21694 87.40802 123.68272 a # 8: 8 63.67433 87.46018 126.63479 a # 9: 9 63.58981 87.88465 116.70405 b # 10: 10 64.35889 85.54751 128.79754 b # 11: 11 66.37115 87.66050 137.00991 b # 12: 12 63.27261 91.40185 124.46477 b # 13: 13 65.53812 91.87163 144.58721 b # 14: 14 67.40902 91.41421 140.32270 b # 15: 15 67.02565 92.08436 139.41926 b # 16: 16 68.65968 98.28665 140.72652 b 4.1 Стандартные методы Стандартные методы ограничены в возможностях, чаще используются для быстрой визуализации “для себя” Функция plot() чаще используется для создания точечных диаграмм plot(x = dt4$x1, y = dt4$y) Некоторые аргументы: xlab - название оси X, ylab - название оси Y, main - - название графика, col - цвет наблюдений plot(x = dt4$x1, y = dt4$x2, xlab = &quot;X1&quot;, ylab = &quot;X2&quot;, col = &quot;red&quot;, main = &quot;Корреляционное поле X1 - X2&quot;) Можно вывести корреляционные поля между всеми переменными на одном графике plot(dt4[,.(y,x1,x2,x3=factor(x3))]) # сменили тип x3 с character на factor Функция hist() - для создания гистограмм Аргумент breaks можно использовать для задания количества классов (если передаём одно число), либо границ классов (если передаём числовой вектор) hist(x = dt4$y, xlab = &quot;Y&quot;, ylab = &quot;Наблюдаемая частота&quot;, col = &quot;red&quot;, main = &quot;Гистограмма Y&quot;, breaks = 6) Функция boxplot() - для создания боксплотов (“ящиков с усами”) boxplot(dt4[,.(y,x1,x2)]) На графике линия внутри ящика - медиана, границы ящика - 1-я (Q1) и 3-я (Q3) квартили, усы - полтора межквартильного размаха (IQR = Q3 - Q1) вверх и вниз от Q3 и Q1 Для создания более сложных и интересных графиков рассмотрим пакеты ggplot2, highcharter, plotly 4.2 Пакет ggplot2 ggplot2 - один из самых популярных пакетов для визуализации в R В ggplot 2 график строится слоями: сначала указываются исходные данные и переменные (внутри функции aes()), после этого - тип графика, после этого - прочие слои (подписи, легенды, свойства осей, оформление). Все слои накладываются друг на друга с помощью оператора +. Например, построим график изменения x1 с ростом порядкового номера id: library(ggplot2) ggplot(dt4, aes(x = id, y = x1)) + # первый слой (данные) и переменные geom_line(col = &#39;red&#39;)+ # второй слой - тип диаграммы (линейная), красного цвета geom_point(size = 2) # третий слой - тип диаграммы (точечная), размером 2 (больше стандартного) Документация по ggplot2 Основные функции: - geom_point() - точечная диаграмма - geom_line() - линия - geom_histogram() - гистограмма - geom_boxplot() - боксплот - geom_smooth() - сглаживающая кривая - geom_text() - текст (подписи данных) - stat_ellipse() - эллипс рассеяния - labs() - задать текст для заголовка, осей, легенды - scale_colour_manual() - задать цветовую шкалу вручную - theme_light() - тема (общее оформление), список тем - scale_x_continuous(), scale_y_continuous() - изменение непрерывных шкал по x и y (trans='log' для логарифмической шкалы) Построим точечную диаграмму с применением большого числа функций (слоёв) ggplot(dt4, aes(x = x1, y = y, size = x2, col = factor(x3), label = id)) + # размер в зависимости от x2, цвет - от x3, подписи - id geom_point(fill=&quot;#D1D1D1&quot;, alpha=0.8, shape=21, stroke=1.3)+ # форма №21, заполнение fill светло-серым, непрозначность 80%, толщина границ 1.3 geom_point(data = dt4[,.(x1=mean(x1), y=mean(y), x2, id),x3], # рассчитали средний y, x1 для каждого x3, x2 и id неважны, но исключить нельзя aes(x=x1,y=y), # отметим среднее по x1 и y color=&quot;black&quot;, # всё черного цвета size=5, # крупный размер (10) shape=3, # форма №3 (форма плюса) stroke = 1.5)+ # форма №21, заполнение fill светло-серым, непрозначность 80%, толщина границ 1.3 geom_text(data = dt4[,.(x1=mean(x1), y=mean(y), x2=0, id=round(cor(y,x1),3)),x3], aes(x=x1,y=y,label=id, col=factor(x3)), # выведем коэффициент корреляции для каждой груммы по x3 size=10, # размер текста alpha=0.3, # на 70% прозрачный nudge_x=3, # смещение по х вправо nudge_y=-3)+ # смещение по y вниз geom_smooth(method = &#39;lm&#39;, # линия сглаживания (прямая) se = F)+ # убрать доверительный интервал geom_text(col = &#39;black&#39;, size = 4, nudge_x = 0.5)+ # добавить подписи черного цвета, рамер 4, смещение по x на 0.5 stat_ellipse(level = 0.9)+ # построить эллипс рассеяния с доверительной вероятностью 0.9 scale_colour_manual(values=c(&quot;#0080FF&quot;, &quot;#FF6666&quot;))+ # задать цветовую шкалу (используем синий и красный) labs(title = &quot;All variables&quot;, # добавить название диаграммы x = &quot;Value of x1&quot;, # название оси х y = &quot;Value of y&quot;)+ # название оси y theme_light() # светлое отображение оси координат Палитра цветов (задавать цвета можно в формате \"#RRGGBB\") Намера для параметра shape и соответствующие формы точек: 4.3 Пакет highcharter С пакетом highcharter графики строятся аналогичным образом (по слоям), с использованием оператора %&gt;% вместо +, результат получается интеравтивным и его можно сохранить как html - страницу. Документация по highcharter Примеры графиков в highcharter Основные функции: - highchart() - создаёт объект типа highchart - hc_xAxis(), hc_yAxis() - настройки осей x, y - hc_yAxis_multiples() - настройки для нескольких осей y - hc_add_series() - добавить ряд данных (линия type = 'line' (по умолчанию), точечный type = 'scatter', столбцовый type = 'column') - hc_title() - добавить название - hc_tooltip() - формат всплывающего окна при наведении на наблюдение - hc_add_theme() - выбрать тему для графика (доступные темы можно найти в документации) - hc_legend() - формат легенды Например, построим график изменения показателей с ростом порядкового номера library(highcharter) highchart() %&gt;% hc_yAxis_multiples( list(opposite = F, title = list(text = &quot;Value of y&quot;), min = dt4[,min(y)-10]), # ось для y: отображение слева, название, минимальное значение list(opposite = T, title = list(text = &quot;Values of x1, x2&quot;)) # ось для x1, x2: отображение справа, название ) %&gt;% hc_xAxis( categories = dt4[, id], # значения по оси x title = list(text = &quot;Number in order&quot;) # название оси x ) %&gt;% hc_add_series(dt4[,round(y,1)], name = &quot;y&quot;, type = &#39;column&#39;, color = &quot;#D1D1D1&quot; # добавили серый столбцовый ряд y ) %&gt;% hc_add_series(dt4[,round(x1,1)], name = &quot;x1&quot;, type = &#39;line&#39;, yAxis = 1, color = &quot;#0080FF&quot; # добавили синюю линию x1 по второй оси ) %&gt;% hc_add_series(dt4[,round(x2,1)], name = &quot;x2&quot;, type = &#39;line&#39;, yAxis = 1, color = &quot;#FF6666&quot; # добавили красную линию x2 по второй оси ) %&gt;% hc_add_theme(hc_theme_google()) %&gt;% # задать тему hc_title(text = &#39;Highcharter plot&#39;) # заголовок графика Построим график зависимости y от x1 c изменением цвета в зависимости от x2 highchart() %&gt;% hc_yAxis( title = list(text = &quot;Value of y&quot;) # название оси y ) %&gt;% hc_xAxis( title = list(text = &quot;Value of x1&quot;) # название оси x ) %&gt;% hc_add_series(dt4, type = &quot;scatter&quot;, hcaes(x = x1, y = y, size = x2, color = colorize (x3, colors = heat.colors(2))) # точечная диаграмма ) %&gt;% hc_tooltip(useHTML = TRUE, headerFormat = &quot;&quot;, pointFormat = tooltip_table( # форматирование всплывающего окна c(&quot;id&quot;, &quot;Value of y&quot;, &quot;Value of x1&quot;, &quot;Value of x2&quot;, &quot;Value of x3&quot;), # как будут отображаться названия переменных c(&quot;{point.id}&quot;, &quot;{point.y:.1f}&quot; , &quot;{point.x1:.1f}&quot; , &quot;{point.x2:.1f}&quot;, &quot;{point.x3}&quot; ) # какие значения выводить по порядку (:.1f - округлить до 1 значения после запятой) )) %&gt;% hc_add_theme(hc_theme_flatdark())%&gt;% # задать тему hc_legend(enabled = F) %&gt;% # убрать легенду hc_title(text = &#39;Highcharter plot&#39;) # заголовок графика "]
]
